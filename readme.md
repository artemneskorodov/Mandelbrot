# Множество Мандельброта

## О проекте

В этом проекте проведено изучение возможностей для оптимизации кода на языках C/C++ с использованием упакованных данных в xmm/ymm регистрах. Также есть возможность компилировать программу для ARM архитектуры. В этом режиме предусмотрена оптимизация с использованием 4 упакованных значений, для этого используются возможности SIMD расширения ARM-процессоров ARM NEON. Множество Мандельброта используется как пример для сложных и долгих вычислений, которые требуют много итераций циклов.

## В проекте использовались

- Библиотека SFML для графического отображения
- Функция clock_gettime() с параметром CLOCK_PROCESS_CPUTIME_ID, который позволяет получить время работы нашего процесса
- Сайт intel intrinsics guide, который позволил находить нужные интринсики для использования

## Что должно получиться в теории

Для оптимизации использовались инструкции, позволяющие делать вычисления не для одной точки, а для 4 или 8. Теоретически это должно ускорять работу программы в ~4 и ~8 раз соотственно. Для измерения времени использовался метод наименьших квадратов. Это позволяет отбросить время которое тратится на задание констант и вызов функций. Производятся измерения зависимости времени исполнения от количества итераций, соответственно коэффициент наклона полученной прямой должен являться временем затрачиваемым на рассчёты для рендера одного экрана.

## Полученные результаты

Полученные значения приведены [здесь](/values.md).

Данные наносим на графики, с помощью метода наименьших квадратов можно оценить погрешность, так как она достаточно случайна при таких измерениях.

### Без оптимизации (x86-64)

График зависимости времени рендеринга от количества итераций при отсутствии оптимизации:
![alt text](https://raw.githubusercontent.com/artemneskorodov/Mandelbrot/92f25651bbb628be3c7a50d1f02e83691fed3ff5/desmos-graph.png)
Время затраченное на просчёт одного кадра:
```math
T_1 = (74.96 ± 0.10) секунд
```
### Оптимизация с данными упакованными по 4 элемента (x86-64)

График зависимости времени рендеринга от количества итераций при оптимизации с использованием 4-ёх упакованных элементов:
![alt text](https://raw.githubusercontent.com/artemneskorodov/Mandelbrot/92f25651bbb628be3c7a50d1f02e83691fed3ff5/desmos-graph-2.png)
Время затраченное на просчёт одного кадра:
```math
T_2 = (18.27 ± 0.02) мс
```
### Оптимизация с данными упакованными по 8 элементов (x86-64)

График зависимости времени рендеринга от количества итераций при оптимизации с использованием 8-ми упакованных элементов:
![alt text](https://raw.githubusercontent.com/artemneskorodov/Mandelbrot/92f25651bbb628be3c7a50d1f02e83691fed3ff5/desmos-graph-3.png)
Время затраченное на просчёт одного кадра:
```math
T_3 = (9.50 ± 0.01) мс
```

### Без оптимизации (arm)

График зависимости времени рендеринга от количества итераций при отсутствии оптимизации для процессора с архитектурой ARM:
![alt text](https://raw.githubusercontent.com/artemneskorodov/Mandelbrot/92f25651bbb628be3c7a50d1f02e83691fed3ff5/arm_no_opt.png)
Время затраченное на просчёт одного кадра:
```math
T_4 = (53.03 ± 0.14) мс
```

### Оптимизация с данными упакованными по 4 элемента (arm)

График зависимости времени рендеринга от количества итераций при отсутствии оптимизации для процессора с архитектурой ARM:
![alt text](https://raw.githubusercontent.com/artemneskorodov/Mandelbrot/92f25651bbb628be3c7a50d1f02e83691fed3ff5/arm_opt.png)
```math
T_5 = (15.20 ± 0.03) мс
```

## Итог
Полученные отношения:
### Отношение времени рендеринга без оптимизации и с использованием интринсиков 128-битных команд для x86-64:
```math
\frac{T_1}{T_2} \approx 4.10
```
### Отношение времени рендеринга без оптимизации и с использованием интринсиков 256-битных команд для x86-64:
```math
\frac{T_1}{T_3} \approx 7.89
```
### Отношение времени рендеринга без оптимизации и с использованием интринсиков 128-битных команд для arm:
```math
\frac{T_4}{T_5} \approx 3.49
```
Это в пределах погрешностей измерений совпадает с примерным предсказанным результатом. Различия могут появляться из-за разных состояний системы в момент исполнения программы. Для архитектуры arm не было найдено быстрой команды, проверяющей, являются ли все числа в регистре нулями, из-за чего ускорение при оптимизации получилось сильно меньше ожидаемого значения.


